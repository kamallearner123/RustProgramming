<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rust Internals Interview Preparation</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f7f9;
            color: #333;
            margin: 0;
            padding: 20px;
            line-height: 1.6;
        }
        header {
            background-color: #007bff;
            color: white;
            padding: 20px;
            text-align: center;
            border-radius: 8px 8px 0 0;
        }
        section {
            background-color: white;
            margin: 20px 0;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        h1, h2, h3 {
            color: #007bff;
        }
        ul {
            list-style-type: disc;
            padding-left: 20px;
        }
        code {
            background-color: #f8f9fa;
            padding: 2px 4px;
            border-radius: 4px;
            font-family: Consolas, monospace;
        }
        pre {
            background-color: #282c34;
            color: #abb2bf;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            font-family: Consolas, monospace;
        }
        pre code {
            background: none;
            padding: 0;
        }
        .keyword { color: #c678dd; }
        .string { color: #98c379; }
        .comment { color: #5c6370; font-style: italic; }
        .function { color: #61afef; }
        .number { color: #d19a66; }
        footer {
            text-align: center;
            margin-top: 40px;
            color: #666;
        }
    </style>
</head>
<body>
    <header>
        <h1>Rust Internals Interview Preparation</h1>
        <p>This guide covers key Rust internals topics for your interview on August 14, 2025. Each section includes practical examples, explanations, and tips to help you succeed.</p>
    </header>

    <section id="ownership-borrowing">
        <h2>1. Ownership and Borrowing</h2>
        <h3>Concepts Covered</h3>
        <ul>
            <li>Ownership rules: Each value has a single owner; when owner goes out of scope, value is dropped.</li>
            <li>Move semantics: Ownership transfer without copying (shallow copy for heap data).</li>
            <li>References: Immutable (&amp;) and mutable (&amp;mut) borrows; no data races.</li>
        </ul>
        <h3>Example: Move Semantics and Borrowing</h3>
        <p>Demonstrates ownership move and borrowing rules.</p>
        <pre><code>
<span class="keyword">fn</span> <span class="function">main</span>() {
    <span class="keyword">let</span> s1 = <span class="function">String</span>::<span class="function">from</span>(<span class="string">"hello"</span>);  <span class="comment">// s1 owns the String</span>
    <span class="keyword">let</span> s2 = s1;  <span class="comment">// Move: s2 now owns it, s1 invalid</span>
    <span class="comment">// println!("{}", s1); // Error: s1 moved</span>
    <span class="function">println!</span>(<span class="string">"{}"</span>, s2);

    <span class="keyword">let</span> s3 = <span class="function">String</span>::<span class="function">from</span>(<span class="string">"world"</span>);
    <span class="keyword">let</span> len = <span class="function">calculate_length</span>(&amp;s3);  <span class="comment">// Immutable borrow</span>
    <span class="function">println!</span>(<span class="string">"Length of '{}' is {}."</span>, s3, len);  <span class="comment">// s3 still valid</span>

    <span class="keyword">let</span> <span class="keyword">mut</span> s4 = <span class="function">String</span>::<span class="function">from</span>(<span class="string">"mutable"</span>);
    <span class="function">change</span>(&amp;<span class="keyword">mut</span> s4);  <span class="comment">// Mutable borrow</span>
    <span class="function">println!</span>(<span class="string">"{}"</span>, s4);
}

<span class="keyword">fn</span> <span class="function">calculate_length</span>(s: &amp;<span class="keyword">String</span>) -> <span class="keyword">usize</span> {
    s.<span class="function">len</span>()
}

<span class="keyword">fn</span> <span class="function">change</span>(s: &amp;<span class="keyword">mut</span> <span class="keyword">String</span>) {
    s.<span class="function">push_str</span>(<span class="string">", changed"</span>);
}
        </code></pre>
        <h3>Why This Example?</h3>
        <p>Illustrates move errors and borrow rules (one mutable or multiple immutables). In the interview, explain how this prevents data races.</p>
        <h3>Interview Tip</h3>
        <p>Discuss the three rules: one owner, no simultaneous mutable borrows, borrows can't outlive owner.</p>
    </section>

    <section id="lifetimes">
        <h2>2. Lifetimes</h2>
        <h3>Concepts Covered</h3>
        <ul>
            <li>Annotations: <code>'a</code> to specify reference lifetimes.</li>
            <li>Elision: Compiler infers lifetimes in common cases.</li>
            <li>Static lifetimes: <code>'static</code> for data living the program's duration.</li>
        </ul>
        <h3>Example: Lifetime Annotations</h3>
        <p>Shows explicit lifetimes for references.</p>
        <pre><code>
<span class="keyword">fn</span> <span class="function">longest</span>&lt;<span class="keyword">'a</span>&gt;(x: &amp;<span class="keyword">'a</span> <span class="keyword">str</span>, y: &amp;<span class="keyword">'a</span> <span class="keyword">str</span>) -> &amp;<span class="keyword">'a</span> <span class="keyword">str</span> {
    <span class="keyword">if</span> x.<span class="function">len</span>() > y.<span class="function">len</span>() {
        x
    } <span class="keyword">else</span> {
        y
    }
}

<span class="keyword">fn</span> <span class="function">main</span>() {
    <span class="keyword">let</span> string1 = <span class="function">String</span>::<span class="function">from</span>(<span class="string">"long string is long"</span>);
    {
        <span class="keyword">let</span> string2 = <span class="function">String</span>::<span class="function">from</span>(<span class="string">"xyz"</span>);
        <span class="keyword">let</span> result = <span class="function">longest</span>(string1.<span class="function">as_str</span>(), string2.<span class="function">as_str</span>());
        <span class="function">println!</span>(<span class="string">"The longest string is {}"</span>, result);
    }

    <span class="keyword">let</span> static_str: &amp;<span class="keyword">'static</span> <span class="keyword">str</span> = <span class="string">"I live forever"</span>;
    <span class="function">println!</span>(<span class="string">"{}"</span>, static_str);
}
        </code></pre>
        <h3>Why This Example?</h3>
        <p>Highlights how lifetimes ensure references don't dangle. The inner scope shows borrow checker enforcement.</p>
        <h3>Interview Tip</h3>
        <p>Explain elision rules and when to use <code>'static</code> (e.g., string literals).</p>
    </section>

    <section id="memory-management">
        <h2>3. Memory Management</h2>
        <h3>Concepts Covered</h3>
        <ul>
            <li>Stack vs. Heap: Stack for fixed-size, heap for dynamic.</li>
            <li><code>Box</code>: Heap allocation with ownership.</li>
            <li><code>Rc</code>/<code>Arc</code>: Reference counting for shared ownership (single/multi-threaded).</li>
        </ul>
        <h3>Example: Using Box, Rc, and Arc</h3>
        <p>Demonstrates heap allocation and shared references.</p>
        <pre><code>
<span class="keyword">use</span> std::rc::<span class="keyword">Rc</span>;
<span class="keyword">use</span> std::sync::<span class="keyword">Arc</span>;
<span class="keyword">use</span> std::thread;

#[<span class="function">derive</span>(<span class="keyword">Debug</span>)]
<span class="keyword">enum</span> List {
    <span class="keyword">Cons</span>(<span class="keyword">i32</span>, <span class="keyword">Box</span>&lt;<span class="keyword">List</span>&gt;),
    <span class="keyword">Nil</span>,
}

<span class="keyword">fn</span> <span class="function">main</span>() {
    <span class="comment">// Box for recursive heap allocation</span>
    <span class="keyword">let</span> list = <span class="keyword">List</span>::<span class="keyword">Cons</span>(<span class="number">1</span>, <span class="keyword">Box</span>::<span class="function">new</span>(<span class="keyword">List</span>::<span class="keyword">Cons</span>(<span class="number">2</span>, <span class="keyword">Box</span>::<span class="function">new</span>(<span class="keyword">List</span>::<span class="keyword">Nil</span>))));
    <span class="function">println!</span>(<span class="string">"{:?}"</span>, list);

    <span class="comment">// Rc for shared ownership</span>
    <span class="keyword">let</span> a = <span class="keyword">Rc</span>::<span class="function">new</span>(<span class="keyword">List</span>::<span class="keyword">Cons</span>(<span class="number">5</span>, <span class="keyword">Rc</span>::<span class="function">new</span>(<span class="keyword">List</span>::<span class="keyword">Cons</span>(<span class="number">10</span>, <span class="keyword">Rc</span>::<span class="function">new</span>(<span class="keyword">List</span>::<span class="keyword">Nil</span>)))));
    <span class="keyword">let</span> b = <span class="keyword">List</span>::<span class="keyword">Cons</span>(<span class="number">3</span>, <span class="keyword">Rc</span>::<span class="function">clone</span>(&amp;a));
    <span class="function">println!</span>(<span class="string">"{:?}"</span>, b);

    <span class="comment">// Arc for multi-threaded sharing</span>
    <span class="keyword">let</span> arc_data = <span class="keyword">Arc</span>::<span class="function">new</span>(<span class="number">42</span>);
    <span class="keyword">let</span> arc_clone = <span class="keyword">Arc</span>::<span class="function">clone</span>(&amp;arc_data);
    <span class="keyword">let</span> handle = thread::<span class="function">spawn</span>(<span class="keyword">move</span> || {
        <span class="function">println!</span>(<span class="string">"In thread: {}"</span>, *arc_clone);
    });
    handle.<span class="function">join</span>().<span class="function">unwrap</span>();
    <span class="function">println!</span>(<span class="string">"Main: {}"</span>, *arc_data);
}
        </code></pre>
        <h3>Why This Example?</h3>
        <p>Shows <code>Box</code> for recursion, <code>Rc</code> for sharing, <code>Arc</code> for threads. Discuss ref counting overhead.</p>
        <h3>Interview Tip</h3>
        <p>Compare to garbage collection: Rust uses RAII for deterministic cleanup.</p>
    </section>

    <section id="concurrency">
        <h2>4. Concurrency</h2>
        <h3>Concepts Covered</h3>
        <ul>
            <li>Threads: <code>std::thread</code> for parallelism.</li>
            <li>Channels: Message passing with <code>mpsc</code>.</li>
            <li>Mutexes/Atomics: Shared state with locks or atomic operations.</li>
        </ul>
        <h3>Example: Threads, Channels, and Mutex</h3>
        <p>Multi-threaded counter with synchronization.</p>
        <pre><code>
<span class="keyword">use</span> std::sync::{<span class="keyword">Arc</span>, <span class="keyword">Mutex</span>, <span class="keyword">mpsc</span>};
<span class="keyword">use</span> std::thread;

<span class="keyword">fn</span> <span class="function">main</span>() {
    <span class="comment">// Channels</span>
    <span class="keyword">let</span> (tx, rx) = <span class="function">mpsc</span>::<span class="function">channel</span>();
    <span class="keyword">let</span> tx_clone = tx.<span class="function">clone</span>();
    thread::<span class="function">spawn</span>(<span class="keyword">move</span> || {
        tx_clone.<span class="function">send</span>(<span class="string">"Hello from thread"</span>).<span class="function">unwrap</span>();
    });
    <span class="function">println!</span>(<span class="string">"Received: {}"</span>, rx.<span class="function">recv</span>().<span class="function">unwrap</span>());

    <span class="comment">// Mutex for shared state</span>
    <span class="keyword">let</span> counter = <span class="keyword">Arc</span>::<span class="function">new</span>(<span class="keyword">Mutex</span>::<span class="function">new</span>(<span class="number">0</span>));
    <span class="keyword">let</span> <span class="keyword">mut</span> handles = <span class="function">vec!</span>[];
    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> {
        <span class="keyword">let</span> counter_clone = <span class="keyword">Arc</span>::<span class="function">clone</span>(&amp;counter);
        <span class="keyword">let</span> handle = thread::<span class="function">spawn</span>(<span class="keyword">move</span> || {
            <span class="keyword">let</span> <span class="keyword">mut</span> num = counter_clone.<span class="function">lock</span>().<span class="function">unwrap</span>();
            *num += <span class="number">1</span>;
        });
        handles.<span class="function">push</span>(handle);
    }
    <span class="keyword">for</span> handle <span class="keyword">in</span> handles {
        handle.<span class="function">join</span>().<span class="function">unwrap</span>();
    }
    <span class="function">println!</span>(<span class="string">"Counter: {}"</span>, *counter.<span class="function">lock</span>().<span class="function">unwrap</span>());
}
        </code></pre>
        <h3>Why This Example?</h3>
        <p>Shows safe concurrency via channels and mutexes. Discuss Send/Sync traits.</p>
        <h3>Interview Tip</h3>
        <p>Explain how Rust prevents data races at compile time.</p>
    </section>

    <section id="trait-system">
        <h2>5. Trait System</h2>
        <h3>Concepts Covered</h3>
        <ul>
            <li>Trait bounds: Constraints like <code>T: Debug</code>.</li>
            <li><code>impl</code>: Implementing traits.</li>
            <li><code>dyn</code> vs. <code>impl Trait</code>: Dynamic dispatch vs. static.</li>
        </ul>
        <h3>Example: Trait Bounds and dyn/impl Trait</h3>
        <p>Custom trait with dynamic and static dispatch.</p>
        <pre><code>
<span class="keyword">trait</span> <span class="keyword">Animal</span> {
    <span class="keyword">fn</span> <span class="function">speak</span>(&amp;<span class="keyword">self</span>) -> <span class="keyword">String</span>;
}

#[<span class="function">derive</span>(<span class="keyword">Debug</span>)]
<span class="keyword">struct</span> Dog;
<span class="keyword">impl</span> <span class="keyword">Animal</span> <span class="keyword">for</span> <span class="keyword">Dog</span> {
    <span class="keyword">fn</span> <span class="function">speak</span>(&amp;<span class="keyword">self</span>) -> <span class="keyword">String</span> {
        <span class="string">"Woof!"</span>.<span class="function">to_string</span>()
    }
}

#[<span class="function">derive</span>(<span class="keyword">Debug</span>)]
<span class="keyword">struct</span> Cat;
<span class="keyword">impl</span> <span class="keyword">Animal</span> <span class="keyword">for</span> <span class="keyword">Cat</span> {
    <span class="keyword">fn</span> <span class="function">speak</span>(&amp;<span class="keyword">self</span>) -> <span class="keyword">String</span> {
        <span class="string">"Meow!"</span>.<span class="function">to_string</span>()
    }
}

<span class="keyword">fn</span> <span class="function">make_speak</span>&lt;<span class="keyword">T</span>: <span class="keyword">Animal</span> + <span class="keyword">Debug</span>&gt;(animal: <span class="keyword">T</span>) {
    <span class="function">println!</span>(<span class="string">"{} says {}"</span>, <span class="function">format!</span>(<span class="string">"{:?}"</span>, animal), animal.<span class="function">speak</span>());
}

<span class="keyword">fn</span> <span class="function">dyn_speak</span>(animal: <span class="keyword">Box</span>&lt;<span class="keyword">dyn</span> <span class="keyword">Animal</span>&gt;) {
    <span class="function">println!</span>(<span class="string">"Dyn says {}"</span>, animal.<span class="function">speak</span>());
}

<span class="keyword">fn</span> <span class="function">impl_trait_speak</span>(animal: <span class="keyword">impl</span> <span class="keyword">Animal</span>) {
    <span class="function">println!</span>(<span class="string">"Impl says {}"</span>, animal.<span class="function">speak</span>());
}

<span class="keyword">fn</span> <span class="function">main</span>() {
    <span class="keyword">let</span> dog = <span class="keyword">Dog</span>;
    <span class="function">make_speak</span>(dog);

    <span class="keyword">let</span> cat = <span class="keyword">Cat</span>;
    <span class="function">dyn_speak</span>(<span class="keyword">Box</span>::<span class="function">new</span>(cat));

    <span class="keyword">let</span> another_dog = <span class="keyword">Dog</span>;
    <span class="function">impl_trait_speak</span>(another_dog);
}
        </code></pre>
        <h3>Why This Example?</h3>
        <p>Compares static (<code>impl Trait</code>) and dynamic (<code>dyn</code>) dispatch. Bounds ensure type safety.</p>
        <h3>Interview Tip</h3>
        <p>Discuss performance: static is monomorphized, dynamic uses vtables.</p>
    </section>

    <section id="unsafe-rust">
        <h2>6. Unsafe Rust</h2>
        <h3>Concepts Covered</h3>
        <ul>
            <li>When to use: For low-level ops like FFI or performance.</li>
            <li>Raw pointers: <code>*const T</code>, <code>*mut T</code>; no borrow checking.</li>
            <li>FFI: Interfacing with C code.</li>
        </ul>
        <h3>Example: Unsafe Raw Pointers and FFI</h3>
        <p>Simple raw pointer dereference and C strlen call.</p>
        <pre><code>
<span class="keyword">extern</span> <span class="string">"C"</span> {
    <span class="keyword">fn</span> <span class="function">strlen</span>(s: *<span class="keyword">const</span> <span class="keyword">u8</span>) -> <span class="keyword">usize</span>;
}

<span class="keyword">fn</span> <span class="function">main</span>() {
    <span class="comment">// Raw pointers</span>
    <span class="keyword">let</span> <span class="keyword">mut</span> num = <span class="number">5</span>;
    <span class="keyword">let</span> r1 = &amp;num <span class="keyword">as</span> *<span class="keyword">const</span> <span class="keyword">i32</span>;
    <span class="keyword">let</span> r2 = &amp;<span class="keyword">mut</span> num <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="keyword">i32</span>;

    <span class="keyword">unsafe</span> {
        <span class="function">println!</span>(<span class="string">"r1: {}"</span>, *r1);
        *r2 = <span class="number">10</span>;
        <span class="function">println!</span>(<span class="string">"r2 modified: {}"</span>, *r2);
    }

    <span class="comment">// FFI example</span>
    <span class="keyword">let</span> hello = <span class="string">b"Hello, world!\0"</span>;
    <span class="keyword">let</span> ptr = hello.<span class="function">as_ptr</span>();
    <span class="keyword">let</span> len = <span class="keyword">unsafe</span> { <span class="function">strlen</span>(ptr) };
    <span class="function">println!</span>(<span class="string">"Length: {}"</span>, len);
}
        </code></pre>
        <h3>Why This Example?</h3>
        <p>Shows when <code>unsafe</code> is needed and risks (undefined behavior if misused).</p>
        <h3>Interview Tip</h3>
        <p>Emphasize <code>unsafe</code> isolates unsafety; always prefer safe Rust.</p>
    </section>

    <section id="compiler-internals">
        <h2>7. Compiler Internals</h2>
        <h3>Concepts Covered</h3>
        <ul>
            <li>Borrow checker: Enforces ownership/borrowing at compile time.</li>
            <li>MIR: Mid-level IR for optimizations.</li>
            <li>Optimization passes: LLVM backend for codegen.</li>
        </ul>
        <h3>Example: Triggering Borrow Checker</h3>
        <p>Code that fails compilation to illustrate borrow checker.</p>
        <pre><code>
<span class="keyword">fn</span> <span class="function">main</span>() {
    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="function">String</span>::<span class="function">from</span>(<span class="string">"hello"</span>);

    <span class="keyword">let</span> r1 = &amp;s;
    <span class="keyword">let</span> r2 = &amp;s;
    <span class="function">println!</span>(<span class="string">"{} and {}"</span>, r1, r2);  <span class="comment">// Multiple immutable OK</span>

    <span class="keyword">let</span> r3 = &amp;<span class="keyword">mut</span> s;
    <span class="comment">// println!("{}", r1); // Error: immutable borrow after mutable</span>
    <span class="function">println!</span>(<span class="string">"{}"</span>, r3);
}
        </code></pre>
        <h3>Why This Example?</h3>
        <p>Triggers borrow checker error; explain MIR role in analysis.</p>
        <h3>Interview Tip</h3>
        <p>Discuss rustc pipeline: parsing -> HIR -> MIR -> LLVM IR.</p>
    </section>

    <section id="how-to-prepare">
        <h2>How to Prepare</h2>
        <p>Dive deep into "The Rust Programming Language" book (official Rust book). Read the Rustonomicon for advanced internals. Experiment with code that triggers borrow checker errors to understand them. Watch Rust conference talks on YouTube (e.g., RustConf). Practice by contributing to open-source Rust crates or rewriting C code in Rust. Use tools like Clippy and Rust Analyzer for insights into compiler behavior.</p>
    </section>

    <footer>
        <p>Prepared by Grok | Best of luck with your interview on August 14, 2025!</p>
    </footer>
</body>
</html>